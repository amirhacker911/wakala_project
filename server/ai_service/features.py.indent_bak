
import hashlib, math, json, os

VECTOR_LEN = 64

def _hash_token(token: str):
    h = hashlib.sha256(token.encode('utf-8')).hexdigest()
    return int(h[:8], 16)

def safe_float(x):
    try:
        return float(x)
    except:
        try:
            return float(str(x).replace(',', '.'))
        except:
            return 0.0

def vectorize(data):
    # Returns fixed-length float vector representing the round features.
    vec = [0.0] * VECTOR_LEN
    if not data or not isinstance(data, dict):
        return vec
    # Bets amounts (mapping option->amount)
    bets = data.get('bets_amounts') or {}
    total = sum([safe_float(v) for v in bets.values()]) or 1.0
    max_bet = max([safe_float(v) for v in bets.values()]) if bets else 0.0
    # basic global features
    try:
        vec[0] = math.log10(total + 1.0)
        vec[1] = math.log10(max_bet + 1.0)
    except Exception:
        vec[0] = 0.0; vec[1] = 0.0
    # options influence
    options = data.get('options') or []
    for i,opt in enumerate(options[:8]):
        am = safe_float(bets.get(opt, 0.0))
        frac = am / total if total>0 else 0.0
        idx = _hash_token(f"opt:{opt}") % VECTOR_LEN
        vec[idx] += frac
    # multipliers
    multipliers = data.get('multipliers') or []
    if multipliers:
        try:
            max_mul = max([safe_float(x) for x in multipliers]) or 1.0
        except:
            max_mul = 1.0
        for m in multipliers:
            try:
                idx = _hash_token(f"mul:{m}") % VECTOR_LEN
                vec[idx] += safe_float(m) / max_mul
            except:
return None  # AUTO_REPLACED_PASS
    # numbers/text-derived features
    nums = data.get('numbers') or []
    for j,n in enumerate(nums[:10]):
        try:
            vec[(4 + j) % VECTOR_LEN] = safe_float(n)
        except:
return None  # AUTO_REPLACED_PASS
    # normalize
    maxv = max(abs(x) for x in vec) or 1.0
    vec = [x / maxv for x in vec]
    return vec
